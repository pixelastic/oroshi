#!/usr/bin/env zsh
# python-fix: Fix a Python file
# Usage:
# $ python-fix ./path/to/file.py                       # Output fixed code to stdout
# $ python-fix --in-place ./path/to/file.py            # Overwrite the file in place
# $ echo "code" | python-fix                           # Bad code from stdin, good code to stdout
# $ echo "code" | python-fix --filepath ./realpath.py  # Specify file location for config resolution

zparseopts -E -D \
  -in-place=flagInPlace \
  -filepath:=flagFilepath
isInPlace=${#flagInPlace}
overridePath=${flagFilepath[2]}

# Work file and temp file
workfileDir="${OROSHI_TMP_FOLDER}/python-fix"
workfilePath="${workfileDir}/python-fix-$RANDOM.py"
tmpPath="${workfilePath}.tmp"
mkdir -p "$workfileDir"

# Check for stdin
hasStdin=0
[[ ! -t 0 ]] && hasStdin=1

# If a file is passed as an argument:
# - inputPath is that file
# - we copy it as workfilePath
if [[ $hasStdin -eq 0 ]]; then
  inputPath="${1:a}"
  cp "$inputPath" "$workfilePath"
fi

# If input is passed as stdin:
# - inputPath is the workfilePath
# - we output stdin into workfilePath
if [[ $hasStdin -eq 1 ]]; then
  inputPath="$workfilePath"
  cat >"$workfilePath"
fi

# Default overridePath value
[[ $overridePath = "" ]] && overridePath="$inputPath"
# Create the tmp file
cp "$workfilePath" "$tmpPath"

# Notes:
# ruff default to updating files in place, but as we need to output to stdout by
# default, we need to operate on copies of files and output their updated
# content.
# Piping content to ruff works, but we need to use --stdin-filename for it to
# resolve any relative filepaths.
# Finally, we need to output the changes to a new file as reading and writing to
# the same file doesn't work.

# Fix linting errors
ruff check \
  --stdin-filename "$overridePath" \
  --fix \
  <"$workfilePath" \
  >"$tmpPath" 2>/dev/null
mv -f "$tmpPath" "$workfilePath"

# Reformat
ruff format \
  --stdin-filename "$overridePath" \
  <"$workfilePath" \
  >"$tmpPath" 2>/dev/null
mv -f "$tmpPath" "$workfilePath"

# Update in place or output to stdout
if [[ $isInPlace = 1 ]]; then
  cp -f "$workfilePath" "$inputPath"
else
  cat "$workfilePath"
fi

rm -f "$workfilePath"
