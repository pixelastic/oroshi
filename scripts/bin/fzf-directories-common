#!/usr/bin/env zsh
# Fuzzy finding in common directories

# We load the functions that are needed. For performance reasons it's better if
# they are defined as zsh function and not binaries
source ~/local/etc/zsh-z/zsh-z.plugin.zsh
source ~/.oroshi/config/zsh/theming/functions/project-by-path.zsh
source ~/.oroshi/config/zsh/theming/functions/colorize-project.zsh

# We get the sorted list of the most used folders
local rawList="$(
z -l \
  | tac \
  | cut -d ' ' -f 1 --complement \
  | awk '{$1=$1;print}' \
)"

# We iterate on each path, to potentially color them using the project prefix
local coloredList=""
local -A invertedList; invertedList=()
for fullPath in ${(f)rawList}; do
  local displayPath="$fullPath/"
  local projectKey="$(project-by-path ${displayPath})"

  # Update display if known project
  if [[ $projectKey != "" ]]; then
    local projectPath=${(P)${:-PROJECT_${projectKey}_PATH}}
    eval "displayPath=\${displayPath:s_${projectPath}_}"

    local projectPrefix="$(colorize-project $projectKey)"

    displayPath="${projectPrefix} ${displayPath}"
  fi

  local coloredLine="[38;5;${COLOR_ALIAS_DIRECTORY}m${displayPath}[00m"
  coloredList+="${coloredLine}\n"

  # Once selected, the line will be stripped of all color characters
  # To be able to find the match later, we'll saved the uncolored line in the
  # inverted list
  local uncoloredLine="$(sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" <<< "$coloredLine")"
  invertedList[$uncoloredLine]=$fullPath
done

# Display all colored path in order.
# head -c -1 removes the last character (a new line)
local rawSelection="$(\
  echo "$coloredList" \
  | head -c -1 \
  | sort \
  | fzf \
    --ansi \
    --color fg:$COLOR_ALIAS_DIRECTORY \
    --color fg+:$COLOR_ALIAS_DIRECTORY \
    --preview 'fzf-preview {}' \
)"

[[ $rawSelection == "" ]] && exit 0

# Switch to the selected tab
local selection=$invertedList[$rawSelection]
echo ${selection:gs/ /\\ /}
