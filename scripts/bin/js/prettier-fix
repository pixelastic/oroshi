#!/usr/bin/env zsh
# prettier-fix: Fix a file using Prettier
# Usage:
# $ prettier-fix ./path/to/file.js                       # Output fixed code to stdout
# $ prettier-fix --in-place ./path/to/file.js            # Overwrite the file in place
# $ echo "<code />" | prettier-fix --parser html               # Code from stdin, with specific parser
# $ echo "<code />" | prettier-fix --filepath ./realpath.html  # Code from stdin, with real location on disk

# ============================================================================
# Parse command-line arguments
# ============================================================================
zparseopts -E -D \
  -in-place=flagInPlace \
  -filepath:=flagFilepath \
  -parser:=flagParser

isInPlace=${#flagInPlace}
overrideFilepath=${flagFilepath[2]}
parser=${flagParser[2]}

# ============================================================================
# Determine input mode and file paths
# ============================================================================
# Check if input is being piped
hasStdin=0
[[ ! -t 0 ]] && hasStdin=1

# When piping content, we need either --parser or --filepath
if [[ $hasStdin == 1 ]]; then
  # Stop if missing arguments
  if [[ $overrideFilepath == "" && $parser == "" ]]; then
    echo "When piping content to prettier-fix, you must specify either --filepath or --parser." >&2
    exit 1
  fi

  # Define a default filepath if only parser is given
  if [[ $overrideFilepath == "" ]]; then
    overrideFilepath="${parser}.${parser}"
  fi

fi

# Resolve file paths
# inputFilepath: the file to read (if not stdin)
# realFilepath: where the file is really located (for config resolution)
inputFilepath="${1:a}"
realFilepath="$inputFilepath"
[[ $overrideFilepath != "" ]] && realFilepath="$overrideFilepath"

# ============================================================================
# Resolve project root
# ============================================================================
projectRoot=$(yarn-root ${realFilepath:h} --force)

# ============================================================================
# Resolve prettier binary
# ============================================================================
prettierBin="prettier"
if [[ $projectRoot != "" && -f "$projectRoot/node_modules/.bin/prettier" ]]; then
  prettierBin="$projectRoot/node_modules/.bin/prettier"
fi
prettierArgs=()

# ============================================================================
# Resolve prettier config file
# ============================================================================
configFile=~/.oroshi/prettier.config.js
if [[ $projectRoot != "" ]]; then
  [[ -f "$projectRoot/prettier.config.js" ]] && configFile="$projectRoot/prettier.config.js"
  [[ -f "$projectRoot/.prettierrc.js" ]] && configFile="$projectRoot/.prettierrc.js"
fi
prettierArgs+=(--config "$configFile")

# ============================================================================
# Build prettier arguments
# ============================================================================
# Disable ignore files so we can format files that are in .prettierignore or .gitignore
prettierArgs+=(--ignore-path=)
# Add parser if specified
[[ $parser != "" ]] && prettierArgs+=(--parser "$parser")

# ============================================================================
# Execute prettier
# ============================================================================

# Input is stdin, output is stdout
if [[ $hasStdin == 1 ]]; then
  local stdinDir="${OROSHI_TMP_FOLDER}/prettier-fix/prettier-fix-$RANDOM"
  mkdir -p "${stdinDir}"

  local stdinFile="${stdinDir}/${realFilepath:t}"
  cat >$stdinFile

  $prettierBin \
    ${prettierArgs[@]} \
    "$stdinFile"
  local exitCode=$?
  rm -rf "$stdinDir"
  exit $exitCode
fi

# Input is a file, fix in place
if [[ $isInPlace == 1 ]]; then
  $prettierBin \
    ${prettierArgs[@]} \
    --write \
    "$inputFilepath" \
    >/dev/null 2>&1
  exit $?
fi

# Input is a file, output to stdout
$prettierBin \
  ${prettierArgs[@]} \
  "$inputFilepath"
