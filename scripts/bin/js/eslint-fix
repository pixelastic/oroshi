#!/usr/bin/env zsh
# eslint-fix: Fix a file using ESLint
# Usage:
# $ eslint-fix ./path/to/file.js                       # Output fixed code to stdout
# $ eslint-fix --in-place ./path/to/file.js            # Overwrite the file in place
# $ echo "var a=42;" | eslint-fix --filepath ./realpath.js  # Code from stdin, with real location on disk

# ============================================================================
# Parse command-line arguments
# ============================================================================
zparseopts -E -D \
  -in-place=flagInPlace \
  -filepath:=flagFilepath \
  -piped=flagPiped

isInPlace=${#flagInPlace}
overrideFilepath=${flagFilepath[2]}
isContentPiped=${#flagPiped}

eslintArgs=()

# ============================================================================
# Detect if content is piped
# ============================================================================
# cat file | eslint-fix
[[ -p /dev/stdin ]] && isContentPiped=1
# eslint-fix < file
[[ -f /dev/stdin ]] && isContentPiped=1

# ============================================================================
# Determine input mode and file paths
# ============================================================================
# When piping content, we need --filepath for context
if [[ $isContentPiped == 1 ]]; then
  # Stop if missing --filepath
  if [[ $overrideFilepath == "" ]]; then
    echo "When piping content to eslint-fix, you must specify --filepath." >&2
    exit 1
  fi
fi

# Resolve file paths
# inputFilepath: the file to read (if not stdin)
# realFilepath: where the file is really located (for config resolution)
inputFilepath="${1:a}"
realFilepath="$inputFilepath"
[[ $overrideFilepath != "" ]] && realFilepath="$overrideFilepath"

# Validate that we have a file path
if [[ "$realFilepath" == "" ]]; then
  echo "Error: no file specified" >&2
  exit 1
fi

# ============================================================================
# Resolve eslint config file
# ============================================================================
configFile=~/.oroshi/eslint.config.js

projectRoot="$(yarn-root ${realFilepath:h} --force)"
if [[ $projectRoot != "" ]]; then
  # Move to root, as this affects eslint resolution of plugins
  cd "$projectRoot" || exit 1

  [[ -f "$projectRoot/.eslintrc.js" ]] && configFile="$projectRoot/.eslintrc.js"
  [[ -f "$projectRoot/eslint.config.js" ]] && configFile="$projectRoot/eslint.config.js"
fi
eslintArgs+=(--config "$configFile")

# ============================================================================
# Execute eslint
# ============================================================================

# Input is stdin, output is stdout
if [[ $isContentPiped == 1 ]]; then
  local stdinDir="${OROSHI_TMP_FOLDER}/eslint-fix/eslint-fix-$RANDOM"
  mkdir -p "${stdinDir}"

  local stdinFile="${stdinDir}/${realFilepath:t}"
  cat >$stdinFile

  eslint_d \
    ${eslintArgs[@]} \
    --stdin \
    --fix-to-stdout \
    --stdin-filename "${realFilepath}" \
    <$stdinFile
  local exitCode=$?
  rm -rf "$stdinDir"
  exit $exitCode
fi

# Input is a file, fix in place
if [[ $isInPlace == 1 ]]; then
  eslint_d \
    ${eslintArgs[@]} \
    --fix \
    "$inputFilepath" 2>/dev/null
  exit $?
fi

# Input is a file, output to stdout
eslint_d \
  ${eslintArgs[@]} \
  --stdin \
  --fix-to-stdout \
  --stdin-filename "$inputFilepath" \
  <$inputFilepath
