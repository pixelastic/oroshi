#!/usr/bin/env zsh
# Returns a list of matches for a given query
# Usage:
# $ fzf-regexp-search-source "query" /path/to/directory

local query="$1"
local directory="$2"

# Adding headings {{{
# ripgrep either displays filename as a heading before all matches, or as
# a prefix before each match. We need it as a heading (for display) AND as
# a prefix (for selection).
# So we'll ask ripgrep to add it as a prefix, and do some crazy regexp to also
# add a heading manually by copying the prefix of the first line of each
# section.

local regexpSearch=""
# We match either the start of the text, or the end of a section separator.
# We defined those to end with an invisible separator for easier splitting.
regexpSearch+="(^|${INVISIBLE_SEPARATOR}\n)"
# We capture the whole line after it, because we'll have to display it again
regexpSearch+="("
# We capture anything that is before a   (the filepath), and captures until the end
# of the line. Sed does not have a non-greedy mode, so we need to explicitly
# define [^\n] to force it to stop at the end of the line.
regexpSearch+="([^\n ]*)   ([^\n]*)"
# We close our line capturing group
regexpSearch+=")\n"

# We replace our matches with by adding a new line above the matching one
local regexpReplace=""
# We re-add our initial delimiter (either start of text, or new line after
# a separator
regexpReplace+="\1"
# We display the filepath twice, and a 0 as the line number, just like any other
# line. The first filepath will be used by the selection, the second one will be
# displayed
regexpReplace+="\3   0   \3"
# We display our matching line again
regexpReplace+="\n\2\n"
# }}}

cd $directory
# Note:
# --null-data makes sed operate on the full text instead of individual lines
# --regexp-extended allow to use () instead of \(\), for readability
rg \
  --no-heading \
  --with-filename \
  "$query" \
  | sed \
      --null-data \
      --regexp-extended \
      "s_${regexpSearch}_${regexpReplace}_g"
