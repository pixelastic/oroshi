# This is a custom link mechanism specifically for Yarn Berry, not Classic
# The link mechanism in Classic requires one to:
# - Go into the module to link and run `yarn link`
# - Then go into the host module and run `yarn link {otherModuleName}`
#
# Yarn Berry simplifies it by only going to the host and running
# `yarn link {pathToOtherModule}`. While the DX is much better, the
# implementation has a lot of bugs, that I don't really understand and have
# a hard time debugging/fixing. It also upgrades the content of package.json,
# which we don't want.
#
# I decided to do my "own" linking, by manually creating symlinks, but keeping
# the same DX.
function yarn-link-berry() {
	local hostRoot="$(yarn-root)"

	local modulePath="${1:a}"
	local moduleName="$(jq -r ".name" ${modulePath}/package.json)"

	# Make a symlink in node_modules
	rm -rf ${hostRoot}/node_modules/${moduleName}
	ln -fs \
		${modulePath} \
		${hostRoot}/node_modules/${moduleName}
	echo "Symlinking ./node_modules/${moduleName} to ${modulePath}"

	# Add the binaries
	local moduleBinaries="$(jq -r \
		'if .bin|type=="string" then
      "\(.name)▮\(.bin)"
    else 
      .bin|to_entries[]|"\(.key)▮\(.value)" 
    end' \
		${modulePath}/package.json
	)"

	for rawLine in ${(f)moduleBinaries}; do
		local split=(${(@s/▮/)rawLine})
		local binaryName=$split[1]
		local binaryPath=$split[2]
		rm -f ${hostRoot}/node_modules/.bin/${binaryName}
		ln -fs \
			../${moduleName}/${binaryPath} \
			${hostRoot}/node_modules/.bin/${binaryName}
		echo "Symlinking local binary ${binaryName}"
	done


}
